use crate::regex::{Capture, NamedCaptureFlavor, Regex, RegexPart};

grammar;

match {
    // Disable whitespace skipping.
    r"" => { },
} else {
    "|" => PIPE,
    "(" => LEFT_PAREN,
    ")" => RIGHT_PAREN,
    "?" => QUESTION_MARK,
    ":" => COLON,
    "<" => LESS_THAN,
    ">" => GREATER_THAN,
    "'" => APOSTROPHE,
    "P" => CAP_LATIN_P,
} else {
    r"." => OTHER_CHAR,
}

pub Regex: RegexPart = {
    () => RegexPart::Empty,
    Alternatives,
}

Alternatives: RegexPart = {
    Sequence,
    <mut part:Alternatives> PIPE <s:Sequence> => match part {
        RegexPart::Alternatives(ref mut alts) => {
            alts.push(s);
            part
        }
        part => RegexPart::Alternatives(vec![part, s]),
    },
};

Sequence: RegexPart = {
    Atom,
    <mut part:Sequence> <c:Atom> => match part {
        RegexPart::Sequence(ref mut items) => {
            items.push(c);
            part
        }
        part => RegexPart::Sequence(vec![part, c]),
    },
};

Atom: RegexPart = {
    CharLiteral<CharClassPlain>,
    Group,
};

Group: RegexPart = {
    LEFT_PAREN <Regex> RIGHT_PAREN => RegexPart::ParenGroup {
        capture: Some(Capture::Index),
        inner: Box::new(<>),
    },
    LEFT_PAREN QUESTION_MARK COLON <Regex> RIGHT_PAREN => RegexPart::ParenGroup {
        capture: None,
        inner: Box::new(<>),
    },
    LEFT_PAREN QUESTION_MARK LESS_THAN <g:GroupName> GREATER_THAN <r:Regex> RIGHT_PAREN
        => RegexPart::ParenGroup
    {
        capture: Some(Capture::Name {
            name: g,
            flavor: NamedCaptureFlavor::Angles,
        }),
        inner: Box::new(r),
    },
    LEFT_PAREN QUESTION_MARK CAP_LATIN_P LESS_THAN <g:GroupName> GREATER_THAN <r:Regex> RIGHT_PAREN
        => RegexPart::ParenGroup
    {
        capture: Some(Capture::Name {
            name: g,
            flavor: NamedCaptureFlavor::AnglesWithP,
        }),
        inner: Box::new(r),
    },
    LEFT_PAREN QUESTION_MARK APOSTROPHE <g:GroupName> APOSTROPHE <r:Regex> RIGHT_PAREN
        => RegexPart::ParenGroup
    {
        capture: Some(Capture::Name {
            name: g,
            flavor: NamedCaptureFlavor::Apostrophes,
        }),
        inner: Box::new(r),
    },
    // TODO: other capture types.
};

GroupName: String = {
    CharClassIdent => String::from(<>),
    <mut name:GroupName> <s:CharClassIdent> => {
        name.push_str(s);
        name
    }
};

CharLiteral<CharClass>: RegexPart = {
    Char<CharClass> => RegexPart::Literal(<>),
};

Char<CharClass>: char = {
    CharClass => <>.chars().next().unwrap(),
};

CharClassPlain = {
    OTHER_CHAR,
    COLON,
    LESS_THAN,
    GREATER_THAN,
    APOSTROPHE,
    CAP_LATIN_P,
};

CharClassIdent = {
    // This is a bit too permissive, but we can filter out unwanted chars during post-processing.
    OTHER_CHAR,
    CAP_LATIN_P,
}
